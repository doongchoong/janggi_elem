TODO:
* 하일라이트, 목표지점 외  그외 수 평가 ( !! 탁월, ! 좋은수, ? 뭔수,  ?? 왜뒀니  이런식의 표기)
* PGN 파서 : 별개 소스로 개발?
* 함수스타일 변경: 엘리먼트에 메서드를 붙이고 전역함수들 제거

----------------------





## 다음 이동, 이전 이동, 한수쉼

시뮬레이션에 속함.  히스토리는

from-to-dead  구조

from은 기물의 원래 위치한곳
to 는 기물이 새로 이동한곳
dead 는  to 에 원래 있던 기물이다. 

다음이동, 이전이동은  이미 있는 history 를 이동하는 것이다. 

한번에 여러단계를 건너뛸순 없고 순차적으로 호출해야한다.

한수쉼은 from to dead 가 전부 없어서   '--' 로 나타난다.




--------------------------

## 애니메이션

기물이 from 위치에서 to 위치로 이동

css의 transition을 이용한다.

position: absolute; transition: all 200ms linear;z-index:9;

먼저 이동을 시킨뒤에  그다음에 left, top 을  현재 기준으로 좌표를 계산하고
0,0 으로 바꾸어서 애니메이션 시킨다. 

origin - target 의 위치가 target 기준으로 origin의 위치이다.

timer를 주어야 transition이 작동한다.


-----------------------

## 클릭 이동 시스템

드래그-드롭은  모바일에서 제대로 동작하지 않음. 
그냥 클릭 으로 변경


선택  <->  이동 을 반복하는 구조

1. 직전 선택이 없는 경우 : 선택모드
2. 직전 선택이 있는 경우
  2.1. 같은 편 기물인 경우 : 선택모드 (변경)
  2.2. 그외 (비어있거나, 상대기물) :  이동 모드 

선택모드일 경우는 이동가능 지점들을 활성화
이동모드일 경우는 이동가능지점 비활성화 

--------------------------

## 포지션 

start 인 경우는 기본 포진대로 , 좌귀마-우귀마 

좌귀마? 우귀마?  어느쪽 귀(코너)에 마가 위치하는지의 여부에 따라 결정
양귀마, 원앙마 

left-knight, right-knight, doubled-knight, coupled-knight

나중에 knight 를 빼던지 해야겠다.

FEN 형태도 지원하도록 함

Fairy-Stockfish 에서는 사용하는 방식대로 기물을 표기함
소문자 : white  초나라
대문자 : black  한나라

r: Rook 차
e: Elephant 상
n: kNight 마
a: Advisor 사
c: Cannon 포
k: King 왕
p: Pawn 졸/병

rena1aenr/4k4/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/4K4/RENA1AENR

위치 표기, 숫자는 빈칸의 숫자

----------------------

## 각 셀별 하일라이트, 목표지점 표기

On/Off 로 끄고 켜는 식으로 하고 나중에 렌더링할때 
클래스를 집어넣고 헤제하는 식으로 표현한다.


-------------------

## 기물 별 이동가능 위치 표시 (Dest) 최종

그냥 각 CELL에서 직선으로 이동가능한 후보들을 미리 구해놓는다. 
그럼 이후 기물별 이동후보 선택하는 로직이 매우 단순해지고 속도가 빨라진다. 
공간을 포기하고 성능을 얻는다.

90개 셀 
  각 셀마다 8방향
    각 방향마다 이동가능한 후보들 리스트

3차원 배열이다.

대부분 4방향 셀이 훨씬 많으므로  
8방향 지정시  상하좌우 부터 지정하고 그뒤에 대각선방향 지정

시작지점을 기준으로 가까운 셀부터 먼셀 순서로 나열되어야함.

예1) 포, 차 는 직선 후보들을 공유함

차는 안막혀있을때까지 빈셀이면 후보를 계속 등록함
포는 안막혀있을때까지 빈셀이면 후보를 등록하지 않고 진행함

차는 막혀있으면 상대기물인지 자기편인지 판단해서 등록여부를 결정하고 종료함
포는 막혀있으면 포인지 확인하고 포가 아니면 그 너머부터는  차와 똑같은 방식으로 후보등록


예2) 차 , 병은 직선 후보들을 공유함

차는 step  제한 없이 끝까지 등록하지만 , 병은 step=1 제한 내에서만 등록함.


예3) 뛰는 기물 (마, 상)은  가장 마지막 후보만 등록함. 

중간 후보들은 등록하지 않고 멱이 막혔는지만 확인함.

예4)  졸/병은  직선 후보들을 사용하지만 정해진 방향으로만 후보를 등록함.





------------------
## 기물 별로 이동가능 위치 표시

규칙에 해당된다. 

장기기물은 움직임 종류는 3가지이다.
1. 장기판 연결 도로로 직선으로 다니는 기물 (졸/병, 차, 포?)
2. 장기판 궁성 도로에서만 직선으로 다니는 기물 (왕, 사)
3. 도로랑 상관없이 뛰어다니는 기물 (마, 상)

3가지 종류의 맵을 만든다. 90개의 셀별로 8방향중 이동가능한 방향을 표시해놓는 맵

궁성맵은 궁성에서만 이동가능,  
일반맵은 대부분 상하좌우  궁성에선 대각선으로도 가능 모서리나 코너에선 제한
점프맵은 모서리 코너만 제한되고 나머지는 8방향 모두 가능

비트로 표기하여 1바이트(8비트). 90바이트면 맵 표기 가능


비트 키는 법 :  비트매스크로  | 연산
비트 끄는 법 :  비트매스크를 ~ (not) 연산 후에 & 연산

cell =  cell | mask;     // 킨다.
cell =  cell & ( ~mask ) // 끈다.



------------------------

## 기물 이미지 구하기

구글링으로 아래 레포를 찾았음
https://github.com/Ka-hu/chess-pieces

라이센스는 CC-BY 4  로 되어있다. 
하지만 이게 라이센스를 명기하지 않을때 그냥 설정되는 것일수도 있다. 
일단 사용.


장기판 렌더링 속도를 위해서 svg를 고정크기 PNG로 변경하고
링크를 걸지 않고 base64로 렌더링 한다.

{
"한나라마.png" : "n",
"한나라상.png" : "e",
....
}

이런식으로 구성한뒤에 
이미지를 하나씩 읽어서 base64로 변환 data url 로 변경함.


---------------------------

## 모든 변동을 처리후 나중에 렌더링

바로바로 변동시키면 나중에 제어하기 힘들어지므로 (한번 리팩토링 함)

변경 분을 메모리상에서만 다 반영한 뒤에 나중에 마지막으로 렌더링을 해서
HTML에 실제로 반영한다. 

예시
1. Highlight Cell
2. Delete Piece 
3. Rendering

렌더링 할때는 DOM의 엘리먼트 자체를 다른 부모를 찾아 appendChild 하게되면
원래 있던곳에서 빠져서 새로 집어넣은곳으로 들어간다. 
굳이 빼는 작업을 안해도 된다.

그래서 렌더링 순서는

1. 숨겨져있는 Hidden 에 기물 엘리먼트를 집어넣어서 숨긴다. 
2. 모든 Cell을 돌면서 원래 위치시켜야 할곳에 위치시킴
3. 남아있는 기물은 삭제

-------------------------

## 파일-랭크 좌표계 시스템

체스의 파일-랭크 좌표계를 사용한다.

랭크는 ROW로 맨위가 10이고 맨 아래가 1이다.
파일은 COL로 좌측이 a 이고 우측이 i 이다.

파일+랭크 로 좌표를 사용한다.   

move b4 c4  => 우측으로 한칸 이동

10
9
8
7
6
5
4
3
2
1
  a b c d e f g h i 


CELL은 자신의 좌표를 가지고 있도록 한다.

만일 한나라의 방향에서 시작하고 싶다면 
Flip Board 
파일 랭크도 서로 뒤집어 져야한다. 

다만 항상 좌표는 똑같게 된다.

1
2
3
4
5
6
7
8
9
10
   i h g f e d c b a


보드를 뒤집을때 모든 Cell에 대해서 
자신의 좌표를 갱신하도록 한다.

---------------------------

## 90칸의 9 x 10 의 그리드를 만들기

CSS 스타일을 이용한다.

display: grid;
grid-template-columns: repeat(9, 11.111%);
grid-template-rows: repeat(10, 10%);

이렇게 하면 따로 row 에 중첩구조로 안만들어도 
알아서 그리드로 생성된다. 

<div class="grid_layout">
  <div cell_id="0"></div>
  <div cell_id="1"></div>
  <div cell_id="2"></div>
  ...
  ...
  <div cell_id="89"></div>
</div>

이렇게 일렬로 DOM 배치시켜놔도 9 x 10으로 나열된다.
